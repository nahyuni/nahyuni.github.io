{"meta":{"title":"","subtitle":"나 혀니의 블로그 입니다.~~","description":"","author":"nahyuni21(Park.S.H)","url":"http://yoursite.com","root":"/"},"pages":[{"title":"all-archives","date":"2021-09-02T14:37:32.996Z","updated":"2021-09-02T14:37:32.996Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2021-09-02T14:37:32.996Z","updated":"2021-09-02T14:37:32.996Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2021-09-02T14:37:32.998Z","updated":"2021-09-02T14:37:32.998Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""},{"title":"about me","date":"2025-06-07T09:25:08.356Z","updated":"2025-06-07T09:25:08.356Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"백엔드 개발, 게임 서버 개발, 네트워크 인프라 구축, 고가용 시스템 구축 설계, 개발, 운영, 인프라 구축. 언어 : java, c#, python, c++, nodejs, php, golang, c DB : mariadb, mysql, mongoDB 운영 체제 : centos, ubuntu, window 프레임워크 : spring boot, nestjs, express, CI 인프라 : docker, jenkins ci/cd, aws, cloudflare, roseHA, galera cluster email : nahyuni21@gmail.com github : https://github.com/nahyuni"}],"posts":[{"title":"smart black box","slug":"dev-smartBBox","date":"2025-06-07T03:24:19.000Z","updated":"2025-06-07T04:26:39.302Z","comments":true,"path":"2025/06/07/dev-smartBBox/","link":"","permalink":"http://yoursite.com/2025/06/07/dev-smartBBox/","excerpt":"개요 영상분석을 통해 안전 감시 시스템을 구축한다. 구축centos7, java1.8, netty 프레임워크, nvr(rtsp, rtp, event, iot, record 등), vms, mysql엣지보드(tx2) : ubuntu, python3, yolov5sar 보드 : 방송 보드(android)** 영상분석 yolov5에서 학습을 통한 모델 구축.1.1 자체 자동 라벨링 툴을 통해 안전모, 화재, 개구부, 사람 객체 데이터를 저장. 실시간 영상처리를 위한 엣지 보드(tx2)에서 인퍼런스.2.1 다중 채널(카메라)을 쓰레드 또는 포크 방식으로 처리.2.2 객체 마다 weigth 조절 가능 처리.2.3 오탐을 방지하기 위해 객체마다 퍼센트 값을 기준으로 대략 70~80% 이상시에 이벤트 전송 안전 감시를 위한 후처리.3.1 해더 및 화재 객체 탐지시 현장 방송 및 서버에 이벤트 패킷을 보내고 서버에서는 뷰어(클라이언트)에게 이벤트를 보내 뷰어는 메세지, 로그, 위험단계(경고, 주의, 위험) 보여줌.3.2 접근감지 이벤트를 위해 감지 라인을 뷰어에서 그리면 해당 좌표와 사람 다리 라인와 거리 측정 및 위험 이벤트 및 현장방송을 전송. 트래킹 및 튜어링을 통한 객체 탐지.4.1 감시 객체(사람, 화재)를 설정 후 프리셋으로 튜어링을 하며, 트래킹 설정 및 객체 탐지에 따라 객체 좌표에 따라 줌인, 줌아웃 및 PTZ를 통해 객체를 카메라 중앙으로 배치 시키고 또한 다중 객체시에는 중앙에 있는 객체를 따라 트래킹 작동.","text":"개요 영상분석을 통해 안전 감시 시스템을 구축한다. 구축centos7, java1.8, netty 프레임워크, nvr(rtsp, rtp, event, iot, record 등), vms, mysql엣지보드(tx2) : ubuntu, python3, yolov5sar 보드 : 방송 보드(android)** 영상분석 yolov5에서 학습을 통한 모델 구축.1.1 자체 자동 라벨링 툴을 통해 안전모, 화재, 개구부, 사람 객체 데이터를 저장. 실시간 영상처리를 위한 엣지 보드(tx2)에서 인퍼런스.2.1 다중 채널(카메라)을 쓰레드 또는 포크 방식으로 처리.2.2 객체 마다 weigth 조절 가능 처리.2.3 오탐을 방지하기 위해 객체마다 퍼센트 값을 기준으로 대략 70~80% 이상시에 이벤트 전송 안전 감시를 위한 후처리.3.1 해더 및 화재 객체 탐지시 현장 방송 및 서버에 이벤트 패킷을 보내고 서버에서는 뷰어(클라이언트)에게 이벤트를 보내 뷰어는 메세지, 로그, 위험단계(경고, 주의, 위험) 보여줌.3.2 접근감지 이벤트를 위해 감지 라인을 뷰어에서 그리면 해당 좌표와 사람 다리 라인와 거리 측정 및 위험 이벤트 및 현장방송을 전송. 트래킹 및 튜어링을 통한 객체 탐지.4.1 감시 객체(사람, 화재)를 설정 후 프리셋으로 튜어링을 하며, 트래킹 설정 및 객체 탐지에 따라 객체 좌표에 따라 줌인, 줌아웃 및 PTZ를 통해 객체를 카메라 중앙으로 배치 시키고 또한 다중 객체시에는 중앙에 있는 객체를 따라 트래킹 작동.","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"yolov5","slug":"yolov5","permalink":"http://yoursite.com/tags/yolov5/"}]},{"title":"Pipe 기반 소켓 처리","slug":"dev-pipesocket-read","date":"2025-06-02T03:24:19.000Z","updated":"2025-06-07T09:10:29.289Z","comments":true,"path":"2025/06/02/dev-pipesocket-read/","link":"","permalink":"http://yoursite.com/2025/06/02/dev-pipesocket-read/","excerpt":"개요 대용량 스트리밍 처리, 빠른 응답성 요구, 메시지 기반 통신 에 적합하다. 구조1234[Socket.ReceiveAsync()] ---&gt; [Pipe.Writer] | v [Pipe.Reader] ---&gt; 메시지 분석, 프로토콜 처리, 비즈니스 로직 이 패턴은 Producer-Consumer 구조로, 소켓 수신자는 Pipe에 데이터만 적재(Write) 데이터 처리는 Pipe에서 소비(Read) Pipe 기반의 처리 장점:버퍼 풀링: GetMemory()로 기존 메모리를 재사용Producer-Consumer 분리: 읽기/쓰기 병렬 가능Zero-Copy 가능성: 성능 극대화 예제123456789101112131415161718192021222324private async Task ProcessLoop()&#123; while (true) &#123; var result &#x3D; await ApplicationPipe.Reader.ReadAsync(); var buffer &#x3D; result.Buffer; &#x2F;&#x2F; 메시지 단위로 자르기 (예: \\n 기준) while (TryReadLine(ref buffer, out var line)) &#123; string text &#x3D; Encoding.UTF8.GetString(line.ToArray()); Console.WriteLine(&quot;받은 메시지: &quot; + text); &#x2F;&#x2F; 응답 처리 or 명령 해석 &#125; &#x2F;&#x2F; 소비한 만큼 Slice ApplicationPipe.Reader.AdvanceTo(buffer.Start, buffer.End); if (result.IsCompleted) break; &#125; ApplicationPipe.Reader.Complete();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107using System.Buffers;using System.IO.Pipelines;using System.Net.WebSockets;using System.Text;public class WebSocketPipeHandler&#123; private readonly WebSocket _webSocket; private readonly Pipe _pipe; public WebSocketPipeHandler(WebSocket webSocket) &#123; _webSocket &#x3D; webSocket; _pipe &#x3D; new Pipe(); &#125; public async Task StartAsync() &#123; var receiveTask &#x3D; ReceiveLoopAsync(); var processTask &#x3D; ProcessLoopAsync(); await Task.WhenAll(receiveTask, processTask); &#125; private async Task ReceiveLoopAsync() &#123; const int bufferSize &#x3D; 1024; try &#123; while (_webSocket.State &#x3D;&#x3D; WebSocketState.Open) &#123; Memory&lt;byte&gt; memory &#x3D; _pipe.Writer.GetMemory(bufferSize); var result &#x3D; await _webSocket.ReceiveAsync(memory, CancellationToken.None); if (result.MessageType &#x3D;&#x3D; WebSocketMessageType.Close) break; _pipe.Writer.Advance(result.Count); var flushResult &#x3D; await _pipe.Writer.FlushAsync(); if (flushResult.IsCompleted || flushResult.IsCanceled) break; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;[ReceiveLoop] Exception: &#123;ex&#125;&quot;); &#125; finally &#123; await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, &quot;Closed&quot;, CancellationToken.None); await _pipe.Writer.CompleteAsync(); &#125; &#125; private async Task ProcessLoopAsync() &#123; try &#123; while (true) &#123; var result &#x3D; await _pipe.Reader.ReadAsync(); var buffer &#x3D; result.Buffer; while (TryReadLine(ref buffer, out var line)) &#123; var text &#x3D; Encoding.UTF8.GetString(line); Console.WriteLine($&quot;[RECEIVED] &#123;text&#125;&quot;); var echo &#x3D; Encoding.UTF8.GetBytes($&quot;Echo: &#123;text&#125;&quot;); await _webSocket.SendAsync(echo, WebSocketMessageType.Text, true, CancellationToken.None); &#125; _pipe.Reader.AdvanceTo(buffer.Start, buffer.End); if (result.IsCompleted) break; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;[ProcessLoop] Exception: &#123;ex&#125;&quot;); &#125; finally &#123; await _pipe.Reader.CompleteAsync(); &#125; &#125; private static bool TryReadLine(ref ReadOnlySequence&lt;byte&gt; buffer, out ReadOnlySpan&lt;byte&gt; line) &#123; var position &#x3D; buffer.PositionOf((byte)&#39;\\n&#39;); if (position &#x3D;&#x3D; null) &#123; line &#x3D; default; return false; &#125; var slice &#x3D; buffer.Slice(0, position.Value); line &#x3D; slice.ToArray().AsSpan(); buffer &#x3D; buffer.Slice(buffer.GetPosition(1, position.Value)); return true; &#125;&#125;","text":"개요 대용량 스트리밍 처리, 빠른 응답성 요구, 메시지 기반 통신 에 적합하다. 구조1234[Socket.ReceiveAsync()] ---&gt; [Pipe.Writer] | v [Pipe.Reader] ---&gt; 메시지 분석, 프로토콜 처리, 비즈니스 로직 이 패턴은 Producer-Consumer 구조로, 소켓 수신자는 Pipe에 데이터만 적재(Write) 데이터 처리는 Pipe에서 소비(Read) Pipe 기반의 처리 장점:버퍼 풀링: GetMemory()로 기존 메모리를 재사용Producer-Consumer 분리: 읽기/쓰기 병렬 가능Zero-Copy 가능성: 성능 극대화 예제123456789101112131415161718192021222324private async Task ProcessLoop()&#123; while (true) &#123; var result &#x3D; await ApplicationPipe.Reader.ReadAsync(); var buffer &#x3D; result.Buffer; &#x2F;&#x2F; 메시지 단위로 자르기 (예: \\n 기준) while (TryReadLine(ref buffer, out var line)) &#123; string text &#x3D; Encoding.UTF8.GetString(line.ToArray()); Console.WriteLine(&quot;받은 메시지: &quot; + text); &#x2F;&#x2F; 응답 처리 or 명령 해석 &#125; &#x2F;&#x2F; 소비한 만큼 Slice ApplicationPipe.Reader.AdvanceTo(buffer.Start, buffer.End); if (result.IsCompleted) break; &#125; ApplicationPipe.Reader.Complete();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107using System.Buffers;using System.IO.Pipelines;using System.Net.WebSockets;using System.Text;public class WebSocketPipeHandler&#123; private readonly WebSocket _webSocket; private readonly Pipe _pipe; public WebSocketPipeHandler(WebSocket webSocket) &#123; _webSocket &#x3D; webSocket; _pipe &#x3D; new Pipe(); &#125; public async Task StartAsync() &#123; var receiveTask &#x3D; ReceiveLoopAsync(); var processTask &#x3D; ProcessLoopAsync(); await Task.WhenAll(receiveTask, processTask); &#125; private async Task ReceiveLoopAsync() &#123; const int bufferSize &#x3D; 1024; try &#123; while (_webSocket.State &#x3D;&#x3D; WebSocketState.Open) &#123; Memory&lt;byte&gt; memory &#x3D; _pipe.Writer.GetMemory(bufferSize); var result &#x3D; await _webSocket.ReceiveAsync(memory, CancellationToken.None); if (result.MessageType &#x3D;&#x3D; WebSocketMessageType.Close) break; _pipe.Writer.Advance(result.Count); var flushResult &#x3D; await _pipe.Writer.FlushAsync(); if (flushResult.IsCompleted || flushResult.IsCanceled) break; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;[ReceiveLoop] Exception: &#123;ex&#125;&quot;); &#125; finally &#123; await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, &quot;Closed&quot;, CancellationToken.None); await _pipe.Writer.CompleteAsync(); &#125; &#125; private async Task ProcessLoopAsync() &#123; try &#123; while (true) &#123; var result &#x3D; await _pipe.Reader.ReadAsync(); var buffer &#x3D; result.Buffer; while (TryReadLine(ref buffer, out var line)) &#123; var text &#x3D; Encoding.UTF8.GetString(line); Console.WriteLine($&quot;[RECEIVED] &#123;text&#125;&quot;); var echo &#x3D; Encoding.UTF8.GetBytes($&quot;Echo: &#123;text&#125;&quot;); await _webSocket.SendAsync(echo, WebSocketMessageType.Text, true, CancellationToken.None); &#125; _pipe.Reader.AdvanceTo(buffer.Start, buffer.End); if (result.IsCompleted) break; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;[ProcessLoop] Exception: &#123;ex&#125;&quot;); &#125; finally &#123; await _pipe.Reader.CompleteAsync(); &#125; &#125; private static bool TryReadLine(ref ReadOnlySequence&lt;byte&gt; buffer, out ReadOnlySpan&lt;byte&gt; line) &#123; var position &#x3D; buffer.PositionOf((byte)&#39;\\n&#39;); if (position &#x3D;&#x3D; null) &#123; line &#x3D; default; return false; &#125; var slice &#x3D; buffer.Slice(0, position.Value); line &#x3D; slice.ToArray().AsSpan(); buffer &#x3D; buffer.Slice(buffer.GetPosition(1, position.Value)); return true; &#125;&#125;","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"Kestrel","slug":"Kestrel","permalink":"http://yoursite.com/tags/Kestrel/"}]},{"title":"consul","slug":"dev-ms-consul","date":"2025-04-14T05:30:19.000Z","updated":"2025-06-06T10:40:11.580Z","comments":true,"path":"2025/04/14/dev-ms-consul/","link":"","permalink":"http://yoursite.com/2025/04/14/dev-ms-consul/","excerpt":"- 사이드카 프록시 로드 밸런서는 Envoy, NGINX, HAProxy, Linkerd입니다. nginxhttps://learn.hashicorp.com/nomad/load-balancing/nginx Envoyhttps://bcho.tistory.com/1297?category=731548","text":"- 사이드카 프록시 로드 밸런서는 Envoy, NGINX, HAProxy, Linkerd입니다. nginxhttps://learn.hashicorp.com/nomad/load-balancing/nginx Envoyhttps://bcho.tistory.com/1297?category=731548 - consul 프록시 설정 방법 서비스 띄움. 1$ .&#x2F;stringsvc **-listen :8081 ** 서비스 등록. 12345678$ vi consul&#x2F;consul.d&#x2F;stringsvc.json&#123; &quot;service&quot;: &#123; &quot;name&quot;: &quot;stringsvc&quot;, &quot;port&quot;: 8081, &quot;connect&quot;: &#123; &quot;sidecar_service&quot;: &#123;&#125; &#125; &#125;&#125; consul dev로 띄움. 1$ .&#x2F;consul agent -dev -config-dir&#x3D;.&#x2F;consul.d 사이드카 등록 및 서비스와 연결. 1$ .&#x2F;consul connect proxy -sidecar-for stringsvc 프록시 등록 및 사이드 카와 연결. 12$ .&#x2F;consul connect proxy -service proxy_stringsvc -upstream stringsvc:9191$ .&#x2F;consul connect proxy -service proxy_stringsvc2 -upstream stringsvc:9192 $ curl -XPOST -d’{“s”:”mytest”}’ http://localhost:9191/stringsvc/count$ curl -XPOST -d’{“s”:”mytest”}’ http://localhost:9192/stringsvc/count$ curl -XPOST -d’{“s”:”mytest”}’ http://localhost:8081/stringsvc/count 다른 방식 서비스 등록.123456789101112131415161718192021&#123; &quot;service&quot;: &#123; &quot;name&quot;: &quot;stringsvc&quot;, &quot;port&quot;: 8081, &quot;connect&quot;: &#123; &quot;sidecar_service&quot;: &#123; &quot;proxy&quot;: &#123; &quot;upstreams&quot;: [&#123; &quot;destination_name&quot;: &quot;stringsvc&quot;, &quot;local_bind_port&quot;: 9191 &#125;, &#123; &quot;destination_name&quot;: &quot;stringsvc&quot;, &quot;local_bind_port&quot;: 9192 &#125; ] &#125; &#125; &#125; &#125;&#125; 1.&#x2F;consul connect proxy -sidecar-for stringsvc 에러뜸(확인중) consul 참조 https://www.consul.io/docs/connect/registration/service-registration.html https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-4Service-Mesh-f8k317qn1b https://www.slideshare.net/SreenivasMakam/service-discovery-using-etcd-consul-and-kubernetes","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"microservice","slug":"microservice","permalink":"http://yoursite.com/tags/microservice/"}]},{"title":"go-kit","slug":"dev-ms-gokit","date":"2025-04-06T05:30:19.000Z","updated":"2025-06-06T10:40:00.036Z","comments":true,"path":"2025/04/06/dev-ms-gokit/","link":"","permalink":"http://yoursite.com/2025/04/06/dev-ms-gokit/","excerpt":"reference http://gokit.io/examples/ https://medium.com/@shijuvar/go-microservices-with-go-kit-introduction-43a757398183 https://github.com/go-kit/kit","text":"reference http://gokit.io/examples/ https://medium.com/@shijuvar/go-microservices-with-go-kit-introduction-43a757398183 https://github.com/go-kit/kit Go kit Architecture Transport layer HTTP or gRPC, or using a pub/sub systems like NATS you can provide multiple transports for a same service Endpoint layer(추상화) Each service method in a Go kit service converts to an endpoint to make RPC style communication between servers and clients Each endpoint exposes the service method to outside world using Transport layer by using concrete transports like HTTP or gRPC Service layer The business logic Go kit service can be exposed by using multiple transports. Service layer 12345678910111213type StringService interface &#123; Uppercase(string) (string, error) Count(string) int&#125;type stringService struct&#123;&#125;func (stringService) Uppercase(s string) (string, error) &#123; if s &#x3D;&#x3D; &quot;&quot; &#123; return &quot;&quot;, ErrEmpty &#125; return strings.ToUpper(s), nil&#125; Endpoint layer1.controller 역할(request, service 호출, response)2.type Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error) 12345678910func makeUppercaseEndpoint(svc StringService) endpoint.Endpoint &#123;return func(ctx context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error) &#123; req :&#x3D; request.(uppercaseRequest) v, err :&#x3D; svc.Uppercase(req.S) if err !&#x3D; nil &#123; return uppercaseResponse&#123;v, err.Error()&#125;, nil &#125; return uppercaseResponse&#123;v, &quot;&quot;&#125;, nil&#125;&#125; Transport layer1.어떻해 전달할 것인가. 1234567 uppercaseHandler :&#x3D; httptransport.NewServer( makeUppercaseEndpoint(svc), decodeUppercaseRequest, encodeResponse,)http.Handle(&quot;&#x2F;uppercase&quot;, uppercaseHandler) 미들웨어 12345678910111213141516171819type logmw struct &#123; logger log.Logger StringService&#125;func (mw logmw) Uppercase(s string) (output string, err error) &#123; defer func(begin time.Time) &#123; _ &#x3D; mw.logger.Log( &quot;method&quot;, &quot;uppercase&quot;, &quot;input&quot;, s, &quot;output&quot;, output, &quot;err&quot;, err, &quot;took&quot;, time.Since(begin), ) &#125;(time.Now()) output, err &#x3D; mw.StringService.Uppercase(s) return&#125; 2. apigateway1. Starting Addsvc go run addsvc.go -debug.addr :7080 -http-addr :7081 -grpc-addr :7082 -thrift-addr :7083 -jsonrpc-addr :7084 curl -XPOST -d’{“a”:”7”,”b”:”4”}’ http://localhost:7081/concat {“v”:”74”} 2. Starting Stringsvc(stringsvc3 example) go run *.go -listen :8081 curl -XPOST -d’{“s”:”mytest”}’ http://localhost:8081/count {“v”:6} 3. Starting Consul First, you need to download Consul for your specific OS/architecture here.(https://www.consul.io/downloads.html) Next1234$ mkdir .&#x2F;consul.d$ echo &#39;&#123;&quot;service&quot;: &#123;&quot;name&quot;: &quot;addsvc&quot;, &quot;tags&quot;: [], &quot;port&quot;: 7082&#125;&#125;&#39; &gt; .&#x2F;consul.d&#x2F;addsvc.json$ echo &#39;&#123;&quot;service&quot;: &#123;&quot;name&quot;: &quot;stringsvc&quot;, &quot;tags&quot;: [], &quot;port&quot;: 8081&#125;&#125;&#39; &gt; .&#x2F;consul.d&#x2F;stringsvc.json$ .&#x2F;consul agent -dev -config-dir&#x3D;.&#x2F;consul.d 4. Starting Api Gateway$ go run main.go -consul.addr :8500 12345678$ curl -XPOST -d&#39;&#123;&quot;a&quot;:&quot;7&quot;,&quot;b&quot;:&quot;4&quot;&#125;&#39; http:&#x2F;&#x2F;localhost:8000&#x2F;addsvc&#x2F;concat&#123;&quot;v&quot;:&quot;74&quot;&#125;$ curl -XPOST -d&#39;&#123;&quot;a&quot;:7,&quot;b&quot;:4&#125;&#39; http:&#x2F;&#x2F;localhost:8000&#x2F;addsvc&#x2F;sum&#123;&quot;v&quot;:11&#125;$ curl -XPOST -d&#39;&#123;&quot;s&quot;:&quot;mytest&quot;&#125;&#39; http:&#x2F;&#x2F;localhost:8000&#x2F;stringsvc&#x2F;count&#123;&quot;v&quot;:6&#125;$ curl -XPOST -d&#39;&#123;&quot;s&quot;:&quot;mytest&quot;&#125;&#39; http:&#x2F;&#x2F;localhost:8000&#x2F;stringsvc&#x2F;uppercase&#123;&quot;v&quot;:&quot;MYTEST&quot;&#125; apigateway 는 consul 서버에 주기적으로 붙어서 서비스 이름으로 서비스 엔드 포인트 정보를 가지고 온다. 클라이언트 호출시에는 직접 서비스 엔드 포인트에 접속해서 데이터를 가지고 온다. 소스는 직접 확인. 참조https://medium.com/@jwenz723/go-kit-api-gateway-4bee401e77a2 3. addsvc 아래와 같이 패키지 되어 있다. 1. pkg addservice(service.go, middleware.go) addendpoint(set.go, middleware.go) addtransport(grpc.go, http.go, jsonrpc.go, thrift.go) 2. addsvc/cmd/addsvc/addsvc.go(사용방법)12345678var ( service &#x3D; addservice.New(logger, ints, chars) endpoints &#x3D; addendpoint.New(service, logger, duration, tracer, zipkinTracer) httpHandler &#x3D; addtransport.NewHTTPHandler(endpoints, tracer, zipkinTracer, logger) grpcServer &#x3D; addtransport.NewGRPCServer(endpoints, tracer, zipkinTracer, logger) thriftServer &#x3D; addtransport.NewThriftServer(endpoints) jsonrpcHandler &#x3D; addtransport.NewJSONRPCHandler(endpoints, logger)) 3. addsvc/cmd/addsvc/addcli.go(사용방법)12svc, err &#x3D; addtransport.NewHTTPClient(*httpAddr, otTracer, zipkinTracer, log.NewNopLogger())svc &#x3D; addtransport.NewGRPCClient(conn, otTracer, zipkinTracer, log.NewNopLogger()) 4. profilesvc 메모리에 저장, 삭제, 조회 함.1234567891011121314151617 type Service interface &#123; PostProfile(ctx context.Context, p Profile) error GetProfile(ctx context.Context, id string) (Profile, error) PutProfile(ctx context.Context, id string, p Profile) error PatchProfile(ctx context.Context, id string, p Profile) error DeleteProfile(ctx context.Context, id string) error GetAddresses(ctx context.Context, profileID string) ([]Address, error) GetAddress(ctx context.Context, profileID string, addressID string) (Address, error) PostAddress(ctx context.Context, profileID string, a Address) error DeleteAddress(ctx context.Context, profileID string, addressID string) error&#125;$ go run .&#x2F;cmd&#x2F;profilesvc&#x2F;main.go -http.addr :8080$ curl -d &#39;&#123;&quot;id&quot;:&quot;1234&quot;,&quot;Name&quot;:&quot;Go Kit&quot;&#125;&#39; -H &quot;Content-Type: application&#x2F;json&quot; -X POST $ http:&#x2F;&#x2F;localhost:8080&#x2F;profiles&#x2F;$ curl localhost:8080&#x2F;profiles&#x2F;1234ts&#x3D;2020-04-06T02:30:46.441838639Z caller&#x3D;middlewares.go:36 method&#x3D;GetProfile id&#x3D;1234 took&#x3D;1.354µs err&#x3D;null&#123;&quot;profile&quot;:&#123;&quot;id&quot;:&quot;1234&quot;,&quot;name&quot;:&quot;Go Kit&quot;&#125;&#125; /cmd/profilesvc/main.go1234567891011121314151617181920212223242526272829303132333435363738func main() &#123; var ( httpAddr &#x3D; flag.String(&quot;http.addr&quot;, &quot;:8080&quot;, &quot;HTTP listen address&quot;) ) flag.Parse() var logger log.Logger &#123; logger &#x3D; log.NewLogfmtLogger(os.Stderr) logger &#x3D; log.With(logger, &quot;ts&quot;, log.DefaultTimestampUTC) logger &#x3D; log.With(logger, &quot;caller&quot;, log.DefaultCaller) &#125; var s profilesvc.Service &#123; s &#x3D; profilesvc.NewInmemService() s &#x3D; profilesvc.LoggingMiddleware(logger)(s) &#125; var h http.Handler &#123; h &#x3D; profilesvc.MakeHTTPHandler(s, log.With(logger, &quot;component&quot;, &quot;HTTP&quot;)) &#125; errs :&#x3D; make(chan error) go func() &#123; c :&#x3D; make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf(&quot;%s&quot;, &lt;-c) &#125;() go func() &#123; logger.Log(&quot;transport&quot;, &quot;HTTP&quot;, &quot;addr&quot;, *httpAddr) errs &lt;- http.ListenAndServe(*httpAddr, h) &#125;() logger.Log(&quot;exit&quot;, &lt;-errs)&#125;","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"microservice","slug":"microservice","permalink":"http://yoursite.com/tags/microservice/"}]},{"title":"RTP,RTCP,RTSP 개요","slug":"dev-rtp","date":"2023-06-12T12:31:00.000Z","updated":"2023-06-12T12:36:14.534Z","comments":true,"path":"2023/06/12/dev-rtp/","link":"","permalink":"http://yoursite.com/2023/06/12/dev-rtp/","excerpt":"- RTP(Real Time Transport Protocol) Viedio/Audio 데이터 전송을 위한 프로토콜. RTP는 불규칙하게 수신되는 데이터의 순서를 정렬하기 위해 타임스탬프 방식을 사용 프로토콜 내부에 위치하는 버퍼의 크기를 각 응용 프로그램마다 별도로 관리하기가 용이함. RTP는 유니 캐스팅뿐만 아니라 멀티캐스팅도 지원한다. 서버에서 클라이언트로 단방향 전송. 해더 마다 코덱이 들어가므로 네트워크 상황에 따라 코덱을 바꿀수 있음. UDP/IP 패킷 전송. 실시간 환경에서는 수신 프로세스에 도착하는 전송 간격이 그대로 유지 되는 것이 중요하므로 버퍼라는 도구를 사용 가변적인 간격으로 도착하는 데이터를 즉시 수신사에 보내지 않고 지연 버퍼를 통해 다시 일정한 간격으로 보정을 하는 역할을 수행한다. RTP 릴레이 기능 고속 네트워크와 저속 네트워크 모두를 만족시키기 위해 데이터 중계 호스트를 규정 믹서(데이터 합성기) 네트워크 대역이 충분하지 않는 경우 개별적으로 데이터를 송신하면 네트워크 대역이 범람하여 부족 현상이 생길 가능성이 있음. 여러 송신 프로세스의 데이터그램을 적절히 조합하여 새로운 데이터그램을 생성한다.ex) 영상과 음성을 믹싱하여 새로운 동영상을 만드는것 트랜슬레이터(속도 변환기) 수신자 환경에 맞게 바꾸어 주는 것을 의미한다. 세션(Session)","text":"- RTP(Real Time Transport Protocol) Viedio/Audio 데이터 전송을 위한 프로토콜. RTP는 불규칙하게 수신되는 데이터의 순서를 정렬하기 위해 타임스탬프 방식을 사용 프로토콜 내부에 위치하는 버퍼의 크기를 각 응용 프로그램마다 별도로 관리하기가 용이함. RTP는 유니 캐스팅뿐만 아니라 멀티캐스팅도 지원한다. 서버에서 클라이언트로 단방향 전송. 해더 마다 코덱이 들어가므로 네트워크 상황에 따라 코덱을 바꿀수 있음. UDP/IP 패킷 전송. 실시간 환경에서는 수신 프로세스에 도착하는 전송 간격이 그대로 유지 되는 것이 중요하므로 버퍼라는 도구를 사용 가변적인 간격으로 도착하는 데이터를 즉시 수신사에 보내지 않고 지연 버퍼를 통해 다시 일정한 간격으로 보정을 하는 역할을 수행한다. RTP 릴레이 기능 고속 네트워크와 저속 네트워크 모두를 만족시키기 위해 데이터 중계 호스트를 규정 믹서(데이터 합성기) 네트워크 대역이 충분하지 않는 경우 개별적으로 데이터를 송신하면 네트워크 대역이 범람하여 부족 현상이 생길 가능성이 있음. 여러 송신 프로세스의 데이터그램을 적절히 조합하여 새로운 데이터그램을 생성한다.ex) 영상과 음성을 믹싱하여 새로운 동영상을 만드는것 트랜슬레이터(속도 변환기) 수신자 환경에 맞게 바꾸어 주는 것을 의미한다. 세션(Session) RTP를 이용하여 통신하는 호스트 그룹을 세션이라는 개념을 이용하여 식별 예를 들어 A와 B가 서로 RTP를 이용해 통신을 한다면, 서로를 연결하는하나의 session이 만들어짐. 이때에 C가 A와 B 의 통신에 참여해도 session은 1개임. UDP와 IP를 이용할 경우 세션은 (수신처 IP + UDP 포트) 조합으로 식별함. 프로토콜 UDP 를 이용함.(RTP + UDP + IP) -&gt; 재전송 패킷은 수신 단말이 재생 시점을 이미 지나가 버린 이후가 될 확률이 높아 패킷을 처리함. 오버해드(40Byte) - ethernet(18) + IP(20) + UDP(8) + RTP(12) + 10ms(160) - DSP칩 G.711 코덱 사용시 =&gt; 초당100개 전송일반적으로 20ms 초당 50개 패킷 생성. RTP 해더(12Byte) 용어 설명 3.1.1 페이로드 타입(Payload Type) - 코덱의 유형(G.711, H264 엔코딩)3.1.2 SSRC : 동기소스 식별자 미디어스트림의 소스 식별함. 1564169535 - 한 웹브라우저에서 2개 동영상 재생.3.1.3 Sequence Number : RTP 패킷 단위로 순차적 할당되는 번호. - RTCP(Real Time Transport Control Protocol)배경 RTP는 데이터 전송만 하는 프로토콜로써 통신 상황을 전하는 체계가 없음. 네트워크가 혼잡할 경우 데이터 전송속도나 전송량 감소. 수신측에서 수신 속도가 전송속도보다 느린 경우 전송측에서 데이터 전송 속도 조절을 할 필요성 발생. 개요 및 특징 RTP 데이터 전송 상태 감시, RTP 세션 제어 프로토콜. 양방향 통신. 주기적으로 송수신자가 리포트 패킷을 주고 받음. RTP 짝수 포트, RTCP RTP 포트 + 1을 사용. RTCP 메세지 종류 ㅇ SR 또는 RS : Sender Report (송신자 보고) - 송신자 측에서 주기적인 품질정보 통계 데이터 . 송신 패킷수 등 ㅇ RR : Receiver Report (수신자 보고) - 수신자 측에서 주기적인 품질정보 통계 데이터 . 패킷손실율, 누적손실패킷수 등 ㅇ SDES : Source Description message - 소스가 자신의 정보를 주기적으로 알림 - SSRC에 해당되는 사용자 이름, 전자우편 주소, 로그인 ID 등으로 송신자 설명 ㅇ BYE : Bye message - 현재 세션에의 모든 참가자에게 종료될 것을 알림 ㅇ APP : Application specfic RTCP - 어플레이션 상호 간에 정보를 전달하기 위해 사용 - RTSP(Real Time Streaming Protocol) RTSP(RealTime Streaming Protocol)은 On Demand 형식으로 리얼타임 미디어 전송을 행하는 애플리케이션 계층의 프로토콜 RTSP는 인터넷 상에서 스트리밍 데이터를 제어하는 방법에 대한 표준안으로 스트리밍 기술이 사용하는 표준 프로토콜 기본포트 554 OPTIONSOPTIONS 요청은 서버의 accept 타입을 반환합니다. DESCRIBEDESCRIBE 요청에는 URL (rtsp://…)이 포함됩니다.기본 포트 554번은 UDP, TCP 둘 다에 사용됩니다. DESCRIBE에 대한 응답 메시지에는 요청한 것에 대한 설명도 포함되는데, 대개 Session Description Protocol (SDP) 형태를 갖추고 있습니다. SETUPSETUP 요청은 단일 미디어 스트림이 전송되어야 하는지 규정합니다. 이 요청은 PLAY 요청 하기 전에 마쳐야 합니다. 그리고 요청할 때 미디어 스트림 URL과 전송점을 포함해야 합니다. 전송점에는 RTP 데이터(오디오/비디오), RTCP 데이터(메타 정보)를 전송받기 위한 포트 번호도 포함됩니다. PLAYPLAY 요청은 하나 또는 모든 미디어 스트림을 재생시킵니다. PLAY 명령은 다중 요청이 가능합니다. 모든 미디어 스트림 재생을 위해서는 URL 집합체가 요청에 포함되어야 합니다. 재생 범위를 구체적으로 지정할 수도 있습니다. 만약 재생 범위를 지정하지 않으면, 미디어 처음부터 끝까지 재생하게됩니다. 또, 일시 정지 상태라면 일시 정지된 위치부터 재생됩니다. PAUSEPLAY 요청은 하나 또는 모든 스트림을 재생시킵니다. PLAY 명령은 다중 요청이 가능합니다. 모든 미디어 스트림 재생을 위해서는 URL 집합체가 요청에 포함되어야 합니다. 일시 정지할때 범위를 구체적으로 지정할 수도 있습니다. RECORDRECORD 요청은 녹화를 위한 명령어입니다. TEARDOWNTEARDOWN 요청은 세션을 종료하기 위한 명령어이고, 모든 미디어 스트림의 재생을 중단하고 서버에 있는 관련 데이터에 걸린 모든 세션도 해제합니다. 참조https://slidesplayer.org/slide/15231455/https://brunch.co.kr/@linecard/154https://copycode.tistory.com/104https://looksense.tistory.com/180http://www.titorus.com/?p=54","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"미디어","slug":"미디어","permalink":"http://yoursite.com/tags/%EB%AF%B8%EB%94%94%EC%96%B4/"}]},{"title":"고가용인프라","slug":"dev-idc-infra","date":"2020-09-24T05:30:19.000Z","updated":"2021-09-02T14:37:32.986Z","comments":true,"path":"2020/09/24/dev-idc-infra/","link":"","permalink":"http://yoursite.com/2020/09/24/dev-idc-infra/","excerpt":"서버 환경1.Web(2EA), DB(4EA), HAProxy(1EA), Backup(1EA)2.CentOS 6.10, Apache : 2.4, PHP : 7.3 MariaDB : 10.3 서버 구성도","text":"서버 환경1.Web(2EA), DB(4EA), HAProxy(1EA), Backup(1EA)2.CentOS 6.10, Apache : 2.4, PHP : 7.3 MariaDB : 10.3 서버 구성도 zenius 모니터링. HAProxy(디비 로드밸런싱) https://findstar.pe.kr/2018/07/27/install-haproxy/ https://en.wikipedia.org/wiki/HAProxy 갈렐라 클러스터 http://rastalion.me/archives/760 https://bcho.tistory.com/1062 RoseHA http://www.ibinfo.co.kr/roseha https://m.blog.naver.com/PostView.nhn?blogId=interikorea1999&amp;logNo=220964505509&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F 기존에는 위에 그림처럼 HAProxy 위에 Galera로 운영을 하였다. 하지만 대용량 데이터를 인써트 업데이트 하기 때문에 Galera Replication 는 데이터 정합성을 중시하므로 시스템에 lock이 빈번히 걸려 시스템을 Galera를 제거, RoseHA 로 바꾸었다. 현재 별 문제 없이 잘 돌아감. HAProxy, Galera -&gt; RoseHA 로 변경 백업 및 복구xtraback","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"infra","slug":"infra","permalink":"http://yoursite.com/tags/infra/"}]},{"title":"streaming 기술 이해","slug":"dev-streaminig","date":"2020-06-24T05:30:19.000Z","updated":"2021-09-02T14:37:32.991Z","comments":true,"path":"2020/06/24/dev-streaminig/","link":"","permalink":"http://yoursite.com/2020/06/24/dev-streaminig/","excerpt":"1. Streaming Service 개요영상 전송 방식은 크게 다운로드 방식 프로그레시브 다운로드 (Prog ressive Download)방식, 스트리밍(Streaming ) 방식으로 구분한다. 1.1 Streaming 이란? 인터넷에서 데이터를 실시간 전송, 구현할 수 있게 하는 기술. 스트리밍은 ‘흐르다’, ‘흘러내리다’, ‘연속되어 끊이지 않고 흐르다’ 등의 의미로,데이터가 조금씩 연속적으로 흘러나온다는 개념과 연관.즉, 어떤 사운드나 비디오 파일을 하나의 형태가 아닌 여러 개의 파일로 나누어물 흐르듯이(Streaming) 연이어 보내는 것.","text":"1. Streaming Service 개요영상 전송 방식은 크게 다운로드 방식 프로그레시브 다운로드 (Prog ressive Download)방식, 스트리밍(Streaming ) 방식으로 구분한다. 1.1 Streaming 이란? 인터넷에서 데이터를 실시간 전송, 구현할 수 있게 하는 기술. 스트리밍은 ‘흐르다’, ‘흘러내리다’, ‘연속되어 끊이지 않고 흐르다’ 등의 의미로,데이터가 조금씩 연속적으로 흘러나온다는 개념과 연관.즉, 어떤 사운드나 비디오 파일을 하나의 형태가 아닌 여러 개의 파일로 나누어물 흐르듯이(Streaming) 연이어 보내는 것. 동영상 파일 등은 용량이 크기 때문에 한꺼번에 파일 전체를 보내주기란 힘들다.이를 해결하기 위해서 조금씩 파일의 일부만(실제로 영상이 플레이되는 분량만큼만) 실시간으로 전송해 주는 것이 ‘스트리밍’이다. 사용자가 접속하고 있는 인터넷 네트워크의 속도에 맞춰 비교적 큰 크기의 스트리밍 파일은 아주 작은 크기의 조각들로 나누어진다. 이 조각들은 각각 뒤의 조각들과 이어질 수 있는 헤더정보를 가지고 전송된다. 구동 프로그램에서는 이조각들을 받으면서 동시에 압축을 풀어 동영상이나 음성으로 재생하게 되는 것. 인터넷에서 동영상을 다운로드가 아닌 실시간 전송에, 실시간 구현이라는 개념을가능케한 것이 바로 스트리밍 기술이다. 1.2 Progressive Download 동영상 파일이 서버로부터 클라이언트에 전달될 때 파일 일부가 도착하는 대로먼저 재생하는 방법 512Kbps의 동영상이라면 적어도 512Kbps의 네트웍 속도가 제공되어야만 동영상이 끊임 없이 제공됩니다. Streaming Service 종류스트리밍 서비스는 크게 영상이나 음성을 받아 서비스하는 라이브 방송과 이미저장된 멀티미디어 데이터를 스트리밍 하는 주문형 서비스로 구성될 수 있다. VoD StreamingLive Streaming 비디오와 오디오를 실시간으로 인코딩해 많은 사용자에게 동시에 제공HTTP Live Streaming 라이브 스트리밍을 위한 전통적인 프로토콜로인 RTP/RTSP는 도입 비용이 높고방화벽 환경에서 서비스가 원활하게 이루어지지 않는 단점이 있다. 이를 보완하기 위해 HTTP를 이용해 원활한 스트리밍 서비스가 가능하도록 Apple이 개발HTTP 라이브 스트리밍(HTTP Live Streaming, HLS)은 가장 대중적인 스트리밍 포맷으로 간주된다HLS는 전반적인 스트림을 크기가 작은 일련의 HTTP 기반 파일 다운로드로 분리시켜 개개의 다운로드를 통해 잠재적으로 무한한 전송 스트림의 작은 덩어리를 적재시킴으로써 동작한다 Streaming 서비스 구성 요소 Server side Streaming Server(Encoding 포함) Web Server Client side Streaming Client Streaming 서비스 동작 원리사용자는 웹서버에 요청하고, 스트리밍 서버는 사용자가 요청한 사항에 대하여멀티미디어 데이터를 보낸다.인코딩 서버는 캠코더나 마이크 등의 장비로부터 받아들이는 아날로그 데이터를압축 기술을 사용하여 디지털 데이터로 바꾸는 기능을 한다. Streaming 관련 기술멀티미디어 스트리밍 기술을 이루는 세 축은 압축 기술, 네트워크 기술, QoS 기술이다. 이 중 압축기술과 네트워크 기술은 없어서는 안 될 중요한 요소이다. 데이터 전송 및 제어 프로토콜RTP(Real-time Transport Protocol)RTCP(Real-Time Transport Control Protocol)RTSP(Real Time Streaming Protocol)MMS(Microsoft Media Server) - 마이크로소프트 네트워크 스트리밍 프로토콜RTMP(Real Time Messaging Protocol) - 어도비 시스템즈사의 독점 컴퓨터 통신 규약 codec(데이터 압축) WMV/WMA H.264(MPEG-4/AVC) MPEG2-TS(Transport Stream) library libavcodec libavcodec은 자유 소프트웨어이자 LGPL 라이선스가 걸린 오픈 소스 라이브러리 이 코덱은 영상 데이터와 음성 데이터를 인코딩하고 디코딩할 수 있다. Streaming 지원 포맷 Container Format 다양한 종류의 데이터 및 표준 데이터 압축 방법을 사용하여 압축된 데이터를 저장할 수 있는 파일 형식 컨테이너 파일은 다양한 종류의 데이터를 확인하고 정리할 수 있다. 컨테이너 포맷은 여러 스트리밍을 재생 치유하는 데 필요한 동기화 정보와 함께 음성, 동영상, 자막, 장( 챕터 ), 자막, 메타 데이터( 태그 ) 등을 지원한다. 확장자 : mp4, mov, mpg, mpeg, wmv, wma, swf, asf, ksg, flv, mkv, tp, ts, rm, mts Streaming Server/ClientStreaming Server RTP ServerRTP로 미디어 패킷들을 클라이언트에게 전송하는 역할을 한다. RTCP를 통해 클라이언트의 수신 대역폭에 따라 전송률을 조정한다. RTSP ServerRTSP를 사용해서 사용자와 통신하는 역할을 한다. RTP가 단방향 통신인데 비해, RTSP는 양방향 통신이다. 사용자는 RTSP를 통해 비디오 요청, 스킵, 멈춤과같은 기능을 사용할 수 있다. Media Packetizer오디오나 비디오와 같은 미디어파일을 그 파일의 포맷에 따라 네트워크로 전송할 수 있는 패킷으로 쪼개는 역할을 한다. Packet BuilderMedia Packetizer에서 쪼갠 미디어 데이터를 RTP 패킷으로 만드는 역할을 한다. open source Darwin Streaming Server 애플의 소스 공개 정책에 따라 윈도우즈와 매킨토시 양쪽을 모두 지원 소스까지 공개되어 있기 때문에 누구든지 무료로 설치 가능 동영상, MP3 등의 디지털미디어를 실시간으로 배포하고 라이브 이벤트를 실현시킬 수 있으며, Linux, Solaris, Windows NT/2000 등 가장 대중적인 엔터프라이즈급 플랫폼을 지원 FFmpeg FFmpeg은 명령어를 직접 입력하는 방식으로 동작하며 여러가지 자유 소프트웨어와 오픈 소스 라이브러리로 구성되어 있다. 라이브러리 중에는 libavcodec도 들어있으며 또, libavformat 라는 음성/영상 다중화, 역다중화 라이브러리도 있다. Streaming Client GStreamer, Media Player Classic, MPEG4IP, MPlayer, QuickTime Streaming 업체 및 기술 동향국내 Streaming 개발 업체 솔루션박스, CDNetworks, 나우콤, 피어링 포털스트리밍 호스팅Gabia, 카페24, Godo, inames 참조https://linuxism.ustd.ip.or.kr/1267https://d2.naver.com/helloworld/7122 - HTTP Live Streaming","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"streaming","slug":"streaming","permalink":"http://yoursite.com/tags/streaming/"}]},{"title":"docker","slug":"dev-ms-docker","date":"2020-04-27T05:30:19.000Z","updated":"2021-09-02T14:37:32.988Z","comments":true,"path":"2020/04/27/dev-ms-docker/","link":"","permalink":"http://yoursite.com/2020/04/27/dev-ms-docker/","excerpt":"0. 도커 배경. 수많은 서버 관리(설치, 설정, 프로세스 실행)를 용이하게 합니다. DevOps의 등장으로 개발주기가 짧아지면서 배포는 더 자주 이루어지고 마이크로서비스 아키텍쳐가 유행하면서 프로그램은 더 잘게 쪼개어져 관리는 더 복잡해집니다. 새로운 툴은 계속해서 나오고 클라우드의 발전으로 설치해야 할 서버가 수백, 수천대에 이르는 상황에서 도커(Docker) 가 등장하고 서버관리 방식이 완전히 바뀌게 됩니다.","text":"0. 도커 배경. 수많은 서버 관리(설치, 설정, 프로세스 실행)를 용이하게 합니다. DevOps의 등장으로 개발주기가 짧아지면서 배포는 더 자주 이루어지고 마이크로서비스 아키텍쳐가 유행하면서 프로그램은 더 잘게 쪼개어져 관리는 더 복잡해집니다. 새로운 툴은 계속해서 나오고 클라우드의 발전으로 설치해야 할 서버가 수백, 수천대에 이르는 상황에서 도커(Docker) 가 등장하고 서버관리 방식이 완전히 바뀌게 됩니다. \\ 1. 도커 개요. 도커는 컨테이너 기반의 오픈소스 가상화 플랫폼입니다. 컨테이너는 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줍니다. 백엔드 프로그램, 데이터베이스 서버, 메시지 큐등 어떤 프로그램도 컨테이너로 추상화할 수 있고 조립PC, AWS, Azure, Google cloud등 어디에서든 실행할 수 있습니다. 2. 도커 구조 프로세스를 격리시키기 때문에 가볍고 빠르게 동작합니다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거의 손실이 없습니다.. 이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않습니다(Immutable). 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다. ubuntu이미지는 ubuntu를 실행하기 위한 모든 파일을 가지고 있고 MySQL이미지는 debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보등을 가지고 있습니다. 3. 도커 설치 및 설정. https://luckygg.tistory.com/165 도커 허브(https://cloud.docker.com) 가입. 4. 도커 명령어 간단 사용법.(우분투 컨테이너로 도커 익히기.) docker ps -a (등록된 컨테이너 리스트 보기) docker search ubuntu (도커 허브에서 이미지 찾기) docker pull ubuntu:latest (우분투 이미지 다운로드) docker run -i -t -v D:\\doc\\docker\\ubuntu:/home/ –name ubuntu_18.4.3 ubuntu /bin/bash(도커 이미지 컨테이너 등록과 실행. /home 폴더에 D:\\cube\\doc\\docker\\ubuntu 해당 디렉토리와 연결함.컨테이너의 Bash 셸로 옵션 -i는 표준 입력(stdin)을 활성화. -t는 TTY 모드(pseudo-TTY)를 사용. -v share volumes .vBash 환경을 쓰려면 -i와 -t 옵션은 기본) docker start ubuntu_18.4.3(컨테이너 시작) docker attach ubuntu_18.4.3(터미널 하나만 사용. 또 들어오면 attach(붙음)됨.) docker exec -it ubuntu_18.4.3 /bin/bash (컨테이너 접속하기) docker inspect ubuntu_18.4.3(컨테이너 세부 정보) docker rm ubuntu_18.4.3(컨테이너 삭제) docker commit -m “메시지” 컨테이너명 이미지명:태그docker를 사용하다 보면 docker container에 특정 프로그램을 설치 한 후 다시 image로 만들고 container를 실행해야 하는 경우가 생긴다.docker container에 특정 프로그램을 설치하고 그대로 사용해도 문제는 없지만 혹여나 설치한 프로그램이 문제가 되어 docker container를 다시 생성해야 할 경우 이전 시점의 docker image가 없다면 복구하기가 어려워 보인다 ctrl + p , ctrl + q - 서버 죽이지 않고 나가기. 5. 도커파일 명령어 FROM: 베이스 이미지를 지정하는 명령어입니다. FROM ubuntu:14.04와 같은 방식으로 사용하고, 버전으로는 latest를 넣을 수도 있습니다. 하지만 가능하면 14.04와 같은 정확한 버전명을 기입하는 것이 좋습니다. RUN: 이미지 상의 리눅스 커맨드를 실행하도록 해주는 명령어입니다.(RUN 명령어는 Dockerfile로부터 이미지를 만들어 낼 때에 실행되는 것입니다.)예를 들어 RUN apt-get -y fortune을 하면 리눅스에서 fortune 라이브러리를 다운로드 받게 됩니다. 이 때 RUN 명령어는 일반적으로 한 번 사용될 때마다 레이어가 하나씩 추가됩니다. 그래서 RUN 명령어를 어떻게 쓰냐에 따라서 이미지의 크기가 달라질 수 있습니다. 그러므로 여러 개의 명령어가 이어지는 경우 다음과 같이 &amp;&amp;를 이용해 하나의 라인에 명령어를 쓰는 것이 좋습니다.RUN apt-get update &amp;&amp; apt-get install -y fortune ADD: build 명령 중간에 호스트의 파일 시스템으로부터 파일을 가져오는 것이다. 말 그대로 이미지에 파일을 더한다(ADD). CMD : 컨테이너 시작 시, 실행될 명령어를 정하는 커맨드이기에 build로 이미지가 만들어지고, 그 이미지로 컨테이너를 run할 때 효력을 갖는다. 컨테이너 시작 시 실행될 명령어이기에 한번만 사용 가능한걸로 알고 있다. 예시를 들어보자. 아래를 입력해 테스트 파일을 생성한다 6. 참조https://subicura.com/2017/01/19/docker-guide-for-beginners-1.htmlhttps://www.bsidesoft.com/?p=7851https://willi.am/blog/2016/07/30/docker-for-windows-sharing-host-volumes/ docker imagehttps://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html 12345678910111213141516171819# 1. ubuntu 설치 (패키지 업데이트 + 만든사람 표시)FROM ubuntu:16.04MAINTAINER subicura@subicura.comRUN apt-get -y update# 2. ruby 설치RUN apt-get -y install rubyRUN gem install bundler# 3. 소스 복사COPY . &#x2F;usr&#x2F;src&#x2F;app# 4. Gem 패키지 설치 (실행 디렉토리 설정)WORKDIR &#x2F;usr&#x2F;src&#x2F;appRUN bundle install# 5. Sinatra 서버 실행 (Listen 포트 정의)EXPOSE 4567CMD bundle exec ruby app.rb -o 0.0.0.0 docker build -t app . docker compose일반적으로 DOCKER를 사용하여 컨테이너를 띄우면 포트 설정이나 볼륨 설정 등을 아래와 같이 할 수 있다.docker run –name sang12-maria -e MYSQL_ROOT_PASSWORD=mypw -d mariadb:latest -p 3306:3306관리하는 컨테이너가 하나이거나 올려야 하는 서비스가 한 종류라면 위와 같이 사용해도 무방할 것이다. 하지만 올려야 하는 컨테이너가 다수이고 서비스도 많다면 일일이 위처럼 명령어를 이용해서 사용하기엔 매우 불편할 것이다. 그래서 Docker Compose가 나온 듯 하다. DOCKER-COMPOSE를 사용하면 아래와 같이 내가 사용하는 서비스를 docker-compose.yml에 저장하여 이용할 수 있다. docker-compose.yml을 작성하는 문법은 version에 따라 다르니, version에 맞는 문법을 사용해야 한다. 12345678910111213141516171819202122232425262728293031version: &#39;3&#39;services: db: image: postgres volumes: - .&#x2F;docker&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data environment: - POSTGRES_DB&#x3D;sampledb - POSTGRES_USER&#x3D;sampleuser - POSTGRES_PASSWORD&#x3D;samplesecret - POSTGRES_INITDB_ARGS&#x3D;--encoding&#x3D;UTF-8 django: build: context: . dockerfile: .&#x2F;compose&#x2F;django&#x2F;Dockerfile-dev environment: - DJANGO_DEBUG&#x3D;True - DJANGO_DB_HOST&#x3D;db - DJANGO_DB_PORT&#x3D;5432 - DJANGO_DB_NAME&#x3D;sampledb - DJANGO_DB_USERNAME&#x3D;sampleuser - DJANGO_DB_PASSWORD&#x3D;samplesecret - DJANGO_SECRET_KEY&#x3D;dev_secret_key ports: - &quot;8000:8000&quot; command: - python manage.py runserver 0:8000 volumes: - .&#x2F;:&#x2F;app&#x2F; 도커 컴포즈의 주요 명령어 docker-compose –version버전 확인 docker-compose up -d docker-compose.yml 파일의 내용에 따라 이미지를 빌드하고 서비스를 실행합니다. 자세한 진행 과정은 다음과 같습니다. 서비스를 띄울 네트워크 설정 필요한 볼륨 생성(혹은 이미 존재하는 볼륨과 연결) 필요한 이미지 풀(pull) 필요한 이미지 빌드(build) 서비스 의존성에 따라 서비스 실행 docker-compose ps현재 환경에서 실행 중인 각 서비스의 상태를 보여줍니다. 참고http://sang12.co.kr/127/CENTOS-%EB%A6%AC%EB%88%85%EC%8A%A4-DOCKER-COMPOSE-%EC%84%A4%EC%B9%98;jsessionid=260D2ACF81D01681912DA629760B5646https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-composehttps://docs.docker.com/compose/compose-file/","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"microservice","slug":"microservice","permalink":"http://yoursite.com/tags/microservice/"}]},{"title":"117회 기출문제","slug":"IMT","date":"2020-04-04T05:30:19.000Z","updated":"2021-09-02T14:37:32.985Z","comments":true,"path":"2020/04/04/IMT/","link":"","permalink":"http://yoursite.com/2020/04/04/IMT/","excerpt":"전체 문제 https://drive.google.com/file/d/1EDwMIPl66b2EfhRbGi0Aj9F5TNljsgp7/view 1. HMAC(Hash-based Message Authentication Code) 날짜 : 0404 레퍼런스 : https://www.joinc.co.kr/w/man/12/hmac 키워드 : Hash,Shared Key,MAC Algorithm 답안전략 : 정확한 메커니즘 설명 및 3 단락에서의 차별화 접근","text":"전체 문제 https://drive.google.com/file/d/1EDwMIPl66b2EfhRbGi0Aj9F5TNljsgp7/view 1. HMAC(Hash-based Message Authentication Code) 날짜 : 0404 레퍼런스 : https://www.joinc.co.kr/w/man/12/hmac 키워드 : Hash,Shared Key,MAC Algorithm 답안전략 : 정확한 메커니즘 설명 및 3 단락에서의 차별화 접근 개념 송신자와 수신자만이 공유하고 있는 Key 와 Message 를 혼합하여 Hash 값을 만드는 방식 HMAC = Hash(Hash(message + key) + key) 특징 메시지의 무결성, 기밀성 보장 알고리즘: MD5, SHA1 분류: HMAC-MD5, HMAC-SHA1 채널을 통해 보낸 메시지가 훼손되었는지 여부를 확인하는데 사용할 수 있음 MAC 의 특성상 역산이 불가능 하므로, 수신된 메시지와 Hash 값을 다시 계산하여, 계산된 HMAC 과 전송된 HMAC 이 일치하는지를 확인하는 방식 프로세스 별도 채널을 이용하여 Sender 와 Receiver 는 해시에 사용할 키(shared key)를 공유. 해시 알고리즘 선정 Sender3.1 message = 전화번호 + 유저아이디;3.2 hash = SHA1(message + Shared Key), message 를 보낸다. Receiver4.1 Sender에서 보낸 message 를 SHA1(message + Shared Key) 로 해서 Sender 의 해시와Receiver 에서 계산한 해시값이 같은지 확인 후 같으면 인증 그렇지 않으면 assert 된다. 해킹 공격에 따른 방어 정책. 다시 보내는 replay 공격에 노출될 수 있으므로 1초에 10번 이상 들어오면 assert 처리함.","categories":[{"name":"정보 관리 기술사","slug":"정보-관리-기술사","permalink":"http://yoursite.com/categories/%EC%A0%95%EB%B3%B4-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EC%88%A0%EC%82%AC/"}],"tags":[]},{"title":"마이크로 서비스 활용","slug":"dev-microservice","date":"2020-03-31T05:30:19.000Z","updated":"2021-09-02T14:37:32.987Z","comments":true,"path":"2020/03/31/dev-microservice/","link":"","permalink":"http://yoursite.com/2020/03/31/dev-microservice/","excerpt":"넷플릭스의 마이크로 서비스 프레임웍 오픈소스 예 사용법이 복잡하다는 것이다. Hystrix 하나만을 적용하는데도 많은 노력이 필요한데, 여러개의 프레임웍을 적용하는 것은 여간 어려운 일이 아니다. 그런데 여기서 스프링 프레임웍이 이런 문제를 풀어내는 기여를 한다. 스프링 프레임웍에 넷플릭스의 마이크로 서비스 오픈 소스 프레임웍을 통합 시켜 버린것이다. (http://spring.io/projects/spring-cloud-netflix) 복잡한 부분을 추상화해서 스프링 프레임웍을 적용하면 손쉽게 넷플릭스의 마이크로 서비스 프레임웍을 사용할 수 있게 해줬는데, 마지막 문제가 남게 된다. 스프링은 자바 개발 프레임웍이다. 즉 자바에만 적용이 가능하다.","text":"넷플릭스의 마이크로 서비스 프레임웍 오픈소스 예 사용법이 복잡하다는 것이다. Hystrix 하나만을 적용하는데도 많은 노력이 필요한데, 여러개의 프레임웍을 적용하는 것은 여간 어려운 일이 아니다. 그런데 여기서 스프링 프레임웍이 이런 문제를 풀어내는 기여를 한다. 스프링 프레임웍에 넷플릭스의 마이크로 서비스 오픈 소스 프레임웍을 통합 시켜 버린것이다. (http://spring.io/projects/spring-cloud-netflix) 복잡한 부분을 추상화해서 스프링 프레임웍을 적용하면 손쉽게 넷플릭스의 마이크로 서비스 프레임웍을 사용할 수 있게 해줬는데, 마지막 문제가 남게 된다. 스프링은 자바 개발 프레임웍이다. 즉 자바에만 적용이 가능하다. 서킷 브레이커서킷 브레이커 패턴은 개념적으로 전기 시스템에서의 회로 차단기/누전 차단기와 같다. 일정 수준(임계치) 이상의 전기를 소모하게 되면 누전 차단기가 작동하는 것처럼 호출하고자 하는 다른 서비스에 문제가 지속해서 생길 경우 해당 문제가 설정한 임계치 기준에 다다르면 서킷(Circuit, 회로)이 열려 차단기가 작동하게 된다. 각 서비스간 의존성이 높은 경우 연속적으로 장애가 발생할수 있다. 이런 의존성 문제를 해결하기 위해 fallback을 활용하여 서비스에 오류가 있더라도 사전에 지정된 응답을 전달하거나 전달받아 다른 서비스에 영향을 주지 않도록 한다. 서킷 브레이커 서비스 매쉬프록시이러한 마이크로 서비스의 문제를 풀기 위해서 소프트웨어 계층이 아니라 인프라 측면에서 이를 풀기 위한 노력이 서비스 매쉬라는 아키텍쳐 컨셉이다. 아래와 같이 서비스와 서비스간의 호출이 있을때 이를 직접 서비스들이 호출을 하는 것이 아니라 서비스 마다 프록시를 넣는다. 이렇게 하면 서비스로 들어오거나 나가는 트래픽을 네트워크 단에서 모두 통제가 가능하게 되고, 트래픽에 대한 통제를 통해서 마이크로 서비스의 여러가지 문제를 해결할 수 있다. 예를 들어 앞에서 설명한 써킷 브레이커와 같은 경우에는 호출되는 서비스가 응답이 없을때 프록시에서 이 연결을 끊어서 장애가 전파되지 않도록 하면된다. 서비스 매쉬 구조를 구현한 오픈 소스 솔루션인 Istiohttps://layer5.io/landscape 아키텍쳐먼저 Istio의 구조를 보자 데이타 플레인 각 프록시들로 이루어져서 트래픽을 설정값에 따라 트래픽을 컨트롤 하는 부분을 데이타 플레인(Data Plane) 컨트롤 플레인 파일럿 (Pilot) - 서비스들의 엔드포인트(EndPoint)들의 주소를 얻을 수 있는 서비스 디스커버리 기능을 제공. 이외도 서비스의 안정성을 제공하기 위해서 서비스간에 호출이 발생할때 재시도(retry), 장애 전파를 막기 위한 써킷 브레이커 (Circuit breaker), Timeout 등의 기능을 제공한다. 믹서(Mixer)믹서가 하는 일은 액세스 컨트롤, 정책 통제 그리고 각종 모니터링 지표의 수집이다.예를 들어서 서비스의 총 처리량을 정책으로 지정하여, 그 처리량 이상으로 요청을 못받게 하거나 특정 헤더값이 일치해야 요청을 받을 수 있게 하는 등의 다양한 정책을 정의하고 이를 컨트롤 할 수 있다.또한 서비스의 응답 시간이나 평균 처리량과 같은 다양한 지표를 수집하여 저장하는 역할을 한다. 시타델(Citadel)시타델은 보안에 관련된 기능을 담당하는 모듈이다. 서비스를 사용하기 위한 사용자 인증 (Authentication)과 인가 (Authorization)을 담당한다. 또한 Istio는 통신을 TLS(SSL)을 이용하여 암호화할 수 있는데, TLS 암호화나 또는 사용자 인증에 필요한 인증서(Certification)을 관리하는 역할을 한다. Istio 설치 및 BookInfo 샘플 애플리케이션 설치https://bcho.tistory.com/1297?category=731548 참조 https://bcho.tistory.com/1293?category=731548","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"microservice","slug":"microservice","permalink":"http://yoursite.com/tags/microservice/"}]},{"title":"마이크로 서비스 구조","slug":"dev-microservice-struct","date":"2020-02-24T05:30:19.000Z","updated":"2021-09-02T14:37:32.987Z","comments":true,"path":"2020/02/24/dev-microservice-struct/","link":"","permalink":"http://yoursite.com/2020/02/24/dev-microservice-struct/","excerpt":"개요마이크로서비스 아키텍처는 하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말합니다.REST API의 일반화, 도커(Docker)와 같은 컨테이너 기술, 클라우드 컴퓨팅 환경의 발전 등에 힘입어 마이크로서비스는 좀 더 손쉽게 구현될 수 있게 되었습니다. 마이크로서비스 아키텍처는 언제 필요한가? 애플리케이션의 배포에 한 시간 이상 소요된다. 단순한 기능 하나를 수정해도 전체 기능에 대한 QA가 필요하다. 단순한 버그 수정이 더 중대한 버그를 생산하는 일이 많아졌다. 현재의 애플리케이션을 기능별로 나눈다고 가정했을 때 수십개의 마이크로서비스가 가능하다.","text":"개요마이크로서비스 아키텍처는 하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말합니다.REST API의 일반화, 도커(Docker)와 같은 컨테이너 기술, 클라우드 컴퓨팅 환경의 발전 등에 힘입어 마이크로서비스는 좀 더 손쉽게 구현될 수 있게 되었습니다. 마이크로서비스 아키텍처는 언제 필요한가? 애플리케이션의 배포에 한 시간 이상 소요된다. 단순한 기능 하나를 수정해도 전체 기능에 대한 QA가 필요하다. 단순한 버그 수정이 더 중대한 버그를 생산하는 일이 많아졌다. 현재의 애플리케이션을 기능별로 나눈다고 가정했을 때 수십개의 마이크로서비스가 가능하다. 모놀리틱 아키텍처 (MONOLITHIC ARCHITECTURE) 일반적인 서비스 구조 마이크로서비스 아키텍처 하나의 큰 서비스를 독립적인 역할을 수행하는 작은 단위의 서비스로 분리하여 설계하는 패턴 여기에서 말하는 독립적인 역할이란 주로, ‘사용자 관리’, ‘주문 관리’, ‘결제 관리’, ‘알림 관리’와 같이 기능적인 요소를 의미 서비스별로 별도의 데이터베이스를 사용 데이터의 특성과 서비스가 가지는 특수성에 따라 가장 효율적인 데이터베이스를 선택 설계 가능. ## 마이크로서비스 아키텍처에서의 요청 처리 ![](/images/6.png) 클라이언트가 모든 마이크로서비스의 호스트명은 물론 end_point를 알고 있어야 한다. API GATEWAY API Gateway는 시스템의 아키텍처를 내부로 숨기고 외부의 요청에 대한 응답만을 적합한 형태로 응답 함. API Gateway는 이처럼 클라이언트의 요청을 일괄적으로 처리하는 역할 뿐만 아니라, 전체 시스템의 부하를 분산시키는 로드 밸런서의 역할, 동일한 요청에 대한 불필요한 반복작업을 줄일 수 있는 캐싱, 시스템상을 오고가는 요청과 응답에 대한 모니터링 역할도 수행할 수 있습니다. 시스템 내부의 아키텍처를 숨길 수 있는(encapsulate) 특성이 API Gateway가 갖는 가장 큰 장점 API GATEWAY 구현시 고려해야할 점들 API Gateway를 비동기(asynchronous)적이고 non-blocking I/O 처리가 가능하도록 구현됨. 개별 마이크로서비스로 보내는 요청의 선후관계가 존재(자바스크립트의 Promise 등으로 구현 가능) 분산된 서버의 상태와 여러가지 변수들로 인해서 일부 서비스에 장애가 발생하거나 응답속도가 지연될 가능성이 높아지게 됨. 특정서비스에 문제가 발생했을 때 API Gateway는 서비스 장애의 종류에 따라 적절한 처리가 가능하도록 설계/구현 되어야 함. API Gateway는 모든 요청이 몰리는 지점이기 때문에 동일한 요청에 대하여 중복적으로 마이크로서비스에 요청을 보내는 것 보다 기존의 결과를 캐싱하여 재활용할 수 있도록 설계하는 것이 중요 프로세스간 통신 IPC(inter-process communication) 동기 메시지 기반 통신동기 요청/응답 기반 : REST, Apache Thrift 비동기 메시지 기반 통신메시지를 전송하는 표준 프로토콜은 AMQP 와 STOMP가 있습니다. 그리고 오픈소스 메시징 시스템에는 RabbitMQ, Apache Kafka, Apache ActiveMQ, NSQ 등이 있습니다. 메시지 포맷통신 방식을 골랐다면 메시지를 어떤 포맷으로 보낼지 골라야 합니다. 먼저 사람이 읽기 쉽고 이해할 수 있는 XML 과 JSON 이 있습니다. XML 은 XML 스키마로 구조를 정의할 수가 있어서 데이터를 쉽게 검증할 수 있지만 메시지 사이즈가 너무 커집니다. JSON 은 XML 보다 가볍지만 데이터를 검증하기가 쉽지 않았습니다. 그래서 JSON 에서도 XML 처럼 데이터를 검증할 수 있도록 만든 것이 JSON 스키마 입니다. 이런 텍스트 기반 메시지는 텍스트를 파싱하는데 오버헤드가 생깁니다. 따라서 성능을 위해 바이너리 값으로 전송하는 방법도 있습니다. 많이 쓰이는 것으로는 binary Thrift 나 Protocol Buffers, Apache Avro. 등이 있습니다. 참조https://futurecreator.github.io/2018/09/14/what-is-microservices-architecture/http://guruble.com/%eb%a7%88%ec%9d%b4%ed%81%ac%eb%a1%9c%ec%84%9c%eb%b9%84%ec%8a%a4microservice-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98-%ea%b7%b8%ea%b2%83%ec%9d%b4-%eb%ad%a3%ec%9d%b4-%ec%a4%91%ed%97%8c%eb%94%94/","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"microservice","slug":"microservice","permalink":"http://yoursite.com/tags/microservice/"}]},{"title":"avalon nano miner","slug":"project-avalon","date":"2020-02-21T05:30:19.000Z","updated":"2022-09-18T12:42:41.323Z","comments":true,"path":"2020/02/21/project-avalon/","link":"","permalink":"http://yoursite.com/2020/02/21/project-avalon/","excerpt":"~~ github 소스 avalon-nano 크롬 소스를 분석한다. 크롬 소스에서 hid SDK(chrome.hid.getDevices)를 nodejs 인 require(“node-hid”) 로컨버팅 한다.(nodejs) avalon-nano USB 디바이스와 접속 후 통신을 한다.(firmware 통신)","text":"~~ github 소스 avalon-nano 크롬 소스를 분석한다. 크롬 소스에서 hid SDK(chrome.hid.getDevices)를 nodejs 인 require(“node-hid”) 로컨버팅 한다.(nodejs) avalon-nano USB 디바이스와 접속 후 통신을 한다.(firmware 통신) 3.1 Avalon4_USB_HID_Protocol_Guide 문서 분석. Packet 총 길이는 40 Byte Head(2) | Type(1) | Opt(1) | Idx(1) | Cnt(1) | Data(32) | Crc(2) 03 version(4) 435 prevhash(32) 3667 merkleRoot(32) 6871 ntime(4) 7275 nbits(4) 7679 nonce(4) 3.2 P_WORK part 1 : midstat(32) =&gt; sha256(input-&gt;(0,64)) version(4) + prevhash(32) + merkleRoot(28) = 64 3.3 P_WORK part 2: id(6) + data(12) 32~37 - poolId(1), jqId(1), nonce2(4) -&gt; id(6) 52~63 - merkleRoot(midstat에 나온 마지막 merkleRoot 4바이트), ntime(4), nbits(4) -&gt; 12 검증 작업(80 Byte) version + prevhash + merkleRoot(32) + ntime + nbits + nonce =&gt; 4바이트 리틀 엔디안으로 바꿔서 더블 해쉬로 만듦.(regen_hash) node-hid 접속123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051r hid &#x3D; require(&quot;node-hid&quot;);var connect &#x3D; function() &#123; dev_con &#x3D; new hid.HID(VENDOR_ID, ID); detect();&#125;;var listen &#x3D; function() &#123; dev_con.on(&quot;data&quot;, myListener);&#125;;function regen_hash(input_str) &#123; var hex &#x3D; SHA256(hex2littlebinary(input_str), 80); return SHA256(hex2bigbinary(hex), 32, 0, 1);&#125;function hex2littlebinary(str)&#123; var result &#x3D; new Array(); for(var i &#x3D; 0; i &lt; str.length; i +&#x3D; 8) &#123; var number &#x3D; 0x00000000; for(var j &#x3D; 0; j &lt; 4; ++j) &#123; number &#x3D; safe_add(number, hex_to_byte(str.substring(i + j*2, i + j*2 + 2)) &lt;&lt; (j*8)); &#125; result.push(number); &#125; return result;&#125;function hex2bigbinary(str)&#123; var result &#x3D; new Array(); for(var i &#x3D; 0; i &lt; str.length; i +&#x3D; 8) &#123; var number &#x3D; 0x00000000; for(var j &#x3D; 0, k &#x3D; 3; j &lt; 4; ++j, --k) &#123; number &#x3D; safe_add(number, hex_to_byte(str.substring(i + j*2, i + j*2 + 2)) &lt;&lt; (k*8)); &#125; result.push(number); &#125; return result;&#125;function hex_to_byte(hex)&#123; return( parseInt(hex, 16));&#125;function safe_add (x, y) &#123; var lsw &#x3D; (x &amp; 0xFFFF) + (y &amp; 0xFFFF); var msw &#x3D; (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16); return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;","categories":[{"name":"프로젝트","slug":"프로젝트","permalink":"http://yoursite.com/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"mining","slug":"mining","permalink":"http://yoursite.com/tags/mining/"},{"name":"blockchain","slug":"blockchain","permalink":"http://yoursite.com/tags/blockchain/"},{"name":"pow","slug":"pow","permalink":"http://yoursite.com/tags/pow/"}]},{"title":"Subversion pre-commit hook","slug":"dev-pre commit hook","date":"2020-02-06T05:30:19.000Z","updated":"2021-09-02T14:37:32.991Z","comments":true,"path":"2020/02/06/dev-pre commit hook/","link":"","permalink":"http://yoursite.com/2020/02/06/dev-pre%20commit%20hook/","excerpt":"Subversion은 Repository Hook이라는 메커니즘을 가지고 있다. pre-commit hook을 사용해, commit하는 내용이나 사용자에 따라, commit할지 말지 여부를 결정하거나, 내용을 수정할 수 있으며, post-commit hook을 사용하면, 모든 commit에 대해 메일을 보내거나 통계를 업데이트할 수 있다. pre-commit hook을 등록 할 때는 다음 세 가지를 신경 쓰면 된다.","text":"Subversion은 Repository Hook이라는 메커니즘을 가지고 있다. pre-commit hook을 사용해, commit하는 내용이나 사용자에 따라, commit할지 말지 여부를 결정하거나, 내용을 수정할 수 있으며, post-commit hook을 사용하면, 모든 commit에 대해 메일을 보내거나 통계를 업데이트할 수 있다. pre-commit hook을 등록 할 때는 다음 세 가지를 신경 쓰면 된다. 실행 가능: Subversion repository의 hooks/pre-commit 파일을 액세스하는 프로그램 (e.g. 웹 서버)이 실행 권한을 가질 수 있도록 해야 한다.exit code: exit code에 따라 commit 여부가 결정된다. 0이라면 commit 성공, 1이라면 commit 실패.stderr: 표준 에러로 출력한 메시지가 클라이언트의 에러 메시지로 출력된다.예를 들어, 공백만 있는 commit log와, 특정 author에 의한 commit을 막으려면 다음과 같은 pre-commit hook 스크립트를 사용하면 된다 123456789101112131415#!/bin/shREPOS=\"$1\"TXN=\"$2\"SVNLOOK=/usr/bin/svnlook$SVNLOOK log -t \"$TXN\" \"$REPOS\" | grep \"[^[:space:]]\" &gt; /dev/nullif [ $? -ne 0 ]; thenecho -n 'EMPTY commit log is NOT ALLOWED' 1&gt;&amp;2exit 1fi$SVNLOOK author -t \"$TXN\" \"$REPOS\" | grep -v -e \"^public$\" &gt; /dev/nullif [ $? -ne 0 ]; thenecho -n 'USER public is NOT ALLOWED' 1&gt;&amp;2exit 1fiexit 0 이러한 hook들은 shell script로만 한정되는 것은 아니므로, python이나 외부 프로그램을 실행하는 스크립트 등의 방식을 활용할 수 있다. Subversion repository에 강제하고 싶은 규칙이 있다면, Subversion의 pre-commit hook을 활용해 보자. 참조http://blog.lastmind.io/archives/592**","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"svn","slug":"svn","permalink":"http://yoursite.com/tags/svn/"}]},{"title":"멀티 플레이어 서버 고찰","slug":"dev-mutisvr","date":"2020-02-06T05:30:19.000Z","updated":"2021-09-02T14:37:32.990Z","comments":true,"path":"2020/02/06/dev-mutisvr/","link":"","permalink":"http://yoursite.com/2020/02/06/dev-mutisvr/","excerpt":"1. 생각해야 될점 반응속도 - 우리게임은 초당 몇번의 패킷을 보내야 하는가.(ex 초당 10번을 목표로 동기화(최대RTT - 100ms)) - 모바일 환경에서의 RTT(불규칙)https://aws.amazon.com/ko/blogs/korea/route53-latency-based-routing/","text":"1. 생각해야 될점 반응속도 - 우리게임은 초당 몇번의 패킷을 보내야 하는가.(ex 초당 10번을 목표로 동기화(최대RTT - 100ms)) - 모바일 환경에서의 RTT(불규칙)https://aws.amazon.com/ko/blogs/korea/route53-latency-based-routing/ 동기화2.1 P2P/CS 사용. 모바일 환경에서 유용한가? 보안(실시간이 아닌 검증으로 되는가?) - 유저간의 레이싱 시작할때 맵정보를 받고 레이싱 끝날때 검증을 한다.(게임서버)맵정보에서 없는 좌표가 들어왔을시 또는 1초 동안의 최대 나올수 있는 좌표 범위를 서버에서 계산해서 문제가 있을 경우 블랙유저로 처리한다. 2. 망 구조 정리(장단점) P2P(보안 약함, 홀펀칭 등 무선 네트워크에서는 변수가 있음.) 대칭피어방식으로 패킷을 보낸다. P2P Lockstep(RTS) 동기화 방식.2.1 명령어를 동시에 내리면 정확히 같은 시점에 모든 피어가 이 명령어를 처리해야 한다.(랜덤 요소가 없어야 한다.) 최대 지연시간 200M 초로 디파인한다.2.2 각 피어(클라이언트)는 저마다 다른 플레임 레이트로 구동되고 접속환경도 품질이 서로 차이가 난다. - 이를 해결하기 위해 턴타이머를 구현해야 한다.2.3 턴 타이머는 명령대기열을 받는 즉시 처리하지 않고 예를들면 한턴(200M)일 경우 두번의 턴이 지난 다음에 처리하므로써 화면에 반영하기까지는 지연시간 까지 합쳐 600M초가 된다. 지연시간에도 불구하고 딱 두턴만 기다려주면 모든 플레이어가 명령을 동시에 처리할수 있다.2.4 최대 지연시간 200M 초를 넘기면 플레이어를 내보내도록 처리한다.2.5 명령어를 메모리에 담기 때문에 리플레이시에 메모리 용량이나 처리부담이 적다.2.6 게임 요소에 난수로 검사할 경우(예를 들면 A인스턴스는 궁수가 보병을 명중시키고, B는 명중을 못시킬 경우) 같은 시드로 같은 횟수로 해야 한다. 홀펀칭이 안되는 경우 릴레이 서버를 이용한다. CS 구조(보안이 필요할 경우, 서버,클라이언트 공수가 큼.) Pure Client-Server - (LOL)서버와 클라이언트가 동기화를 맞춰준다. (Ex: LOL)클라이언트에서 Input을 주면, 서버에서 게임 로직을 처리한다. 서버가 게임 오브젝트들의 상태를 동기화한다.상태정보가 틀어지기 때문에 클라이언트는 서버에서 보내주는 값들을 자연스럽게 보간 및 예측만 해주면 된다.Peer-to-Peer LockStep처럼 가장 느린 클라이언트에 동기화를 맞춰주는게 아니라 서버에 동기화를 맞춰주기 때문에 다른 클라이언트에 영향을 받지 않는다.당연하지만 서버가 느려질 경우에는 모두가 느려진다.서버의 허락을 받고 명령이 수락되는 방식이기 때문에 해킹에 강한 편이지만, 서버에 허락을 받아야 하기 때문에 반응 속도가 떨어지는 편이다.그리고 Latency가 조금이라도 높아지는 날에는 게임이 지옥으로 변하게 된다. - 온라인에서나 가능할거 같음. Client-Side Prediction (Reconciliation)Client-Server 방식과 비슷하지만, 클라이언트에서 먼저 계산하고, 서버와 오차를 보정해 나가면서 동기화를 맞추는 것이 차이점이다.주로 빠른 반응성이 필요한 FPS(Ex: 콜오브듀티) 게임 등에서 많이 사용되고 있다.서버와 클라이언트 간의 오차를 줄여주는 것이 매우 힘든 작업이다. CS with Lockstep 방식(starcraft)3.1 서버에서 각 피어의 역활을 한다. 그외에 방식은 다 똑같음.3.2 서버에서 게임로직 처리. 혼합 구조.(RTS 방식이 아님) 클라이언트는 홀펀칭을 시도후에 안되면 게임서버(Relay)에 접속한다. 홀펀칭이 성공하면 P2P로 1초에 4번 정도 이동패킷을 보내며, 이중에 5~6번마다 한번씩 서버에게 보낸다.(실시간 검증 - 이동 패킷이 허용범위를 넘었을 경우 해킹 유저로 보고 끊는다.) 서버(게임서버)는 이것을 다른 유저에게 relay한다. 이동패킷을 제외한 패킷의 경우는 P2P로 보낸후 서버에게도 패킷을 보낸다.(평균 2~3초에 한번 보냄) 패킷을 받는 클라이언트는 P2P든, 서버든 가장 빨리 “보내는 쪽”을 먼저 처리하고 뒤이어 온 패킷은 “무시” 한다. 서버는 TCP/IP를 사용한다. 단순 릴레이 구조.(CS 구조) 클라이언트에서 보내는것을 게임서버는 그대로 Relay를 한다. 게임 세션 및 검증을 게임서버에서 한다.(실시간이 아닌 검증) 자료모바일 게임에서의 실시간 멀티플레이에서 P2P와 CS 네트워킹의 비교 http://www.codeinfo.net/bbs/board.php?bo_table=pra_view&amp;wr_id=6CS 동기화 관련 자료 http://yakolla.tistory.com/62P2P RTS 와 CS 관련 자료 https://pegasuskim.wordpress.com/2015/12/23/%EC%84%9C%EB%B2%84-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AA%A8%EB%8D%B8/ 3. 그 밖에 참고 EA코리아에서 만든 realracing3은 Time Shifted Multiplayer (비실시간 멀티플레이어) 로 만듦. 뜻은 시간을 옮겨놓은(즉, 서로간의 플레이 시간이 일치하지 않는) 멀티플레이어를 뜻한다TSM 은 사용자들의 주행 데이터를 기반으로 한 인공지능 봇이다. 인터넷이 켜져 있으면 다른 사용자들의 아이디와 프로필 사진, 랩타임을 이용하는 것이고, 꺼져있으면 기본 탑재된 TSM 이 나온다.가끔 TSM 끼리 서로 경쟁하는 모습도 보이곤 하지만 그렇게 적극적인 것은 아니며, 모든 TSM 이 레이싱라인을 따라서 너무나도 질서정연하게 달리기 때문에, TSM 에 실시간 멀티플레이와 같은 변칙적이며 전투적인 플레이를 기대해서는 안 된다","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"game svr","slug":"game-svr","permalink":"http://yoursite.com/tags/game-svr/"}]},{"title":"BridgeWar","slug":"project-bridgewar","date":"2020-01-21T05:30:19.000Z","updated":"2021-09-02T14:37:32.993Z","comments":true,"path":"2020/01/21/project-bridgewar/","link":"","permalink":"http://yoursite.com/2020/01/21/project-bridgewar/","excerpt":"1. 서버 구성도","text":"1. 서버 구성도 2. 개발 환경 AWS(ec2, Elastic Load balancer, DBS) + Centos 7.0 + apache + CI(php) + mysql + memcached + mcrypt 3. 프로세스 Rest API로 통신을 했으며 json으로 데이터 형식을 표현. 데이터는 레퍼런스, 유저, 로그, 통합 데이터로 구분. 분산 디비를 위해 몇십만 이상시에 로그와 유저 디비가 생성하도록 하였고 맴캐쉬에 레퍼런스 데이터를 저장하도록 함.(유저 키로 구분) 세션마다 키를 주어 암호화 함.(mcrypt) 클라이언트에서 서버 에러시에 서버에 로그를 남기도록 함. 매칭 및 랭킹은 통합 디비에서 실시간 매칭과 랭킹으로 구현. 채팅 서버를 채널별 로드 밸런싱을 하였고 여러개의 프로세스로 분산화 함 이벤트와 각종 서비스를 셀로 구현8.1 프로세스 죽었을시에 sms 날리고 다시 살리는 셀.(DB, 아파치, 채팅)8.2 매일 통계 데이터 넣는 부분 셀.8.3 health check 셀.8.4 오래된 맬 삭제 셀.8.5 각종 이벤트 셀. 4. 미들웨어5. 아마존 서버 구성DB(2대) db.m4.xlarge - cpu 4, memory 16 SSD 100GWEB(3대) m4.xlarge - cpu 4, memory 16 SSD 80GElastic Load Balancer 6. 설치 및 설정memcache 설치 맴케쉬는 web01에서만 설치한다. memcache 설치yum install zlib-devel1.1 PHP memcache 설치/home/bridgewar/util/memcache-2.2.6 tar -xvf memcache-2.2.6.tgz phpize, ./configure, make, make install mcrypt 설치 yum -y install php-mcrypt snappy 설치yum install snappysudo 계정cd php-ext-snappy-master(rpm -qa | grep snappy-1.1.0-3.el7.x86_64) cd php-snappy phpize ./configure make make install /etc/php.ini 설정extension=mcrypt.soextension=snappy.soextension=memcache.sotimezone 확인. 7. cron8. back up","categories":[{"name":"프로젝트","slug":"프로젝트","permalink":"http://yoursite.com/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"game svr","slug":"game-svr","permalink":"http://yoursite.com/tags/game-svr/"}]},{"title":"monitoring","slug":"project-monitoring","date":"2020-01-21T05:30:19.000Z","updated":"2021-09-02T14:37:32.994Z","comments":true,"path":"2020/01/21/project-monitoring/","link":"","permalink":"http://yoursite.com/2020/01/21/project-monitoring/","excerpt":"1. 개요 여러개의 open source 가 있지만 간단한 내부 모니터 및 알람 툴이다. 클라이언트(view) : 웹, 아이폰, 안드로이드 앱(react-native 웹앱 구현), view monitoring 서버(admin) : 서버 환경 : centos6.9, mysql5.5, shell, php7.3 프로세스","text":"1. 개요 여러개의 open source 가 있지만 간단한 내부 모니터 및 알람 툴이다. 클라이언트(view) : 웹, 아이폰, 안드로이드 앱(react-native 웹앱 구현), view monitoring 서버(admin) : 서버 환경 : centos6.9, mysql5.5, shell, php7.3 프로세스 5.1 어드민에서 프로젝트 등록 및 프로젝트 사용자 권한 설정을 한다.5.2 알람 어드민 툴에서 알람 임계치를 설정하여 (관심, 주의, 경고, 위험, 바로조치) sms를 보낼수 있다.5.3 모니터링 하고 싶은 서버에 설치 문서에 따라 설치 및 설정을 한다.5.4 해당 시스템은 크론에 등록되어 매분 체크 된다.5.5 뷰에서 시스템 정보 및 알람 정보를 확인할수 있다.5.6 기본적인 모니터링 셀 구현. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/bin/bashroot_path=\"/home/www/common_cron/alarm_admin\";if [ $# -gt 0 ]then echo \" Usage : ./monitor.sh\" exitfisource $root_path/alarm_info.iniactive_ok=`$mysql_path -h$alarm_host -u$alarm_user -p$alarm_pwd $alarm_db -e \"SELECT active_ok FROM svr_register WHERE pro_name = '$pro_name' AND svr_name = '$svr_name'\"`active_ok=`echo \"$active_ok\" | grep -E 'yes|no'`if [ $active_ok = \"no\" ] || [ $active_ok = '' ]then exitfiecho \"pro_name : $pro_name, svr_name : $svr_name\";load_avg=`uptime | awk '&#123;print $(NF-2)\" \"$(NF-1)\" \"$NF&#125;'`cpu=`/usr/bin/mpstat | tail -1 | awk '&#123;print 100 - $12&#125;'`memory=`free | grep -i mem: | awk '&#123;print $3/$2 * 100&#125;'`io_wait=`iostat -c|awk '/^ /&#123;print $4&#125;'`disk=`df -h`net_id=`netstat -i | awk '&#123;print $1&#125;' | grep -iv lo | grep -iv Iface | grep -iv Kernel`for i in $net_iddo network_rx_error=`netstat -i | grep $i | awk '&#123;print $5&#125;'` network_tx_error=`netstat -i | grep $i | awk '&#123;print $9&#125;'`doneSTART=$(date +%s)if [ $svr_name == \"db\"* ] || [ $svr_name == \"all\" ]then# echo \"mysql -u$local_user -p'$local_pwd' $local_db &lt; alarm_query.sql\" mysql -u$local_user -p$local_pwd $local_db &lt; alarm_query.sqlfiEND=$(date +%s)query_sec=$(( $END - $START ))http_cnt=`netstat -nap | grep :80 | grep ESTABLISHED | wc -l`ping_sec=`ping -c 1 localhost | grep icmp_seq | awk '&#123;print $8&#125;'`ping_sec=$&#123;ping_sec:5:10&#125;;db_live_num=`ps -ef | grep mysql | egrep -v grep | wc -l`;http_live_num=`ps -ef | grep httpd | egrep -v grep | wc -l`;db_live_ok='yes';if [ $db_live_num -lt 1 ]then if [ $svr_name == \"db\"* ] || [ $svr_name == \"all\" ] then db_live_ok='no'; fifihttp_live_ok='yes';if [ $http_live_num -lt 1 ]then if [ $svr_name == \"web\"* ] || [ $svr_name == \"all\" ] then http_live_ok='no'; fifi$mysql_path -h$alarm_host -u$alarm_user -p$alarm_pwd $alarm_db -e \"INSERT INTO system_log (pro_name, svr_name, load_avg, cpu, memory, io_wait, disk, network_rx_error, network_tx_error, query_sec, http_cnt, ping_sec, db_live_ok, http_live_ok, ip, joindate) VALUES ('$pro_name', '$svr_name', '$load_avg', '$cpu', '$memory', '$io_wait', '$disk', '$network_rx_error', '$network_tx_error', '$query_sec', '$http_cnt', '$ping_sec', '$db_live_ok', '$http_live_ok', '127.0.0.1', now())\" 2. alarm story board3. alarm-admin, alarm-view 정보4. 설치 및 설정 /home/www/alarm_admin/_cron 모니터링 시스템에 설치 및 설정. alarm_info.ini 수정. - monitor.sh 레퍼 크론 등록####### alarm##* * * * * /home/www/common_cron/alarm_admin/monitor.sh##* * * * * /usr/bin/php /home/www/common_cron/alarm_admin/work_alarm.php sendPush.php - andriod12345678910111213141516171819202122232425262728293031 private function send_notification($tokens, $message, $re_num)&#123; $url = $this-&gt;url; $fields = array( 'registration_ids' =&gt; $tokens, 'data' =&gt; $message ); $key = $this-&gt;serverKey; $headers = array( 'Authorization:key =' . $key, 'Content-Type: application/json' ); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_HTTPHEADER, $headers); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt ($ch, CURLOPT_SSL_VERIFYHOST, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($fields)); $result = curl_exec($ch); if ($result === FALSE) &#123; die('Curl failed: ' . curl_error($ch)); &#125; curl_close($ch); echo \"Result : \".$re_num.\" \".$result.\"&lt;br&gt;&lt;br&gt;\\n\\n\"; //return $result;&#125;","categories":[{"name":"프로젝트","slug":"프로젝트","permalink":"http://yoursite.com/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"cron","slug":"cron","permalink":"http://yoursite.com/tags/cron/"}]},{"title":"기본 300 문장 암기 - 제시카","slug":"eng-daily","date":"2020-01-21T05:30:19.000Z","updated":"2021-09-02T14:37:32.992Z","comments":true,"path":"2020/01/21/eng-daily/","link":"","permalink":"http://yoursite.com/2020/01/21/eng-daily/","excerpt":"[0401]https://www.youtube.com/watch?v=ebSETnkZkq0&amp;list=PLMHmzjQsn8r-P1MODIuH7jefDmZ5dNahd i will be rigth back with you give me a call a piece of cake(쉬워)","text":"[0401]https://www.youtube.com/watch?v=ebSETnkZkq0&amp;list=PLMHmzjQsn8r-P1MODIuH7jefDmZ5dNahd i will be rigth back with you give me a call a piece of cake(쉬워) any good ideas? better than noting(없는거 보다 낫다) cat i get a ride? cheers don’t get too serious - don’t be scared enjoy your meal forget it(됬어 잊어버려~) Nice talking to you. how have you been? i am exhausted. i didn’t mean it(의도 하지 않았어) i feel the same way.(동의해) i’m coming. keep in touch(연락 하자) let’s try. Maybe some other time.(다음에 하자) no sweat.(껌이에요) - 스웻 Ouch.(정전기가 났어) Shoot(슛) 이런. stop complaining. take care(잘있어~) that’s the way to go(그래 그렇게 하는거지) we are in the same boat.(우리 같은 처지야.) what brings you here(무슨일로 오셨어요?) who’s there? (거기 누구에요?) you stay out of it.(끼어들지마 빠져~) 아러브잇 [0403] are you in line?() are you serious? have a seat. can i get a ride?(태워줄래요) catch you later.(담에 또 보자.) Did you get it(알아 들었어?) Don’t be a chicken(겁쟁이 되지 마.) Don’t push me(강요하지마) exactly(맞아) for what?(그래서 모?) give it a try go get it(가서 가져와) 승리를 가져와~ grow up! 철좀 들어라. he didn’t show up(나타 나지 않았다.) help youself.(많이 드세요) how was your trip?(여행 어땠어) /how was your food? /how was your vacation? how’s work? how’s family? how’s buisiness? i’m getting hungry(슬슬 배고픈데) i’m getting tired i am impressed (인상적이었어. 좋았어) i can’t help it. (어쩔수 없어) i got lost(길 잃었다) i have no idea(전혀 모르겠다.) i’ll get it.(제가 할께요) it ‘s out of style(옛날꺼야) it takes time.(시간이 좀 걸려) it’s your turn(니 차례야) let me see(나도 보여줘) no way shame on you(부끄러운 줄 알어~) speak out(크게 말해요) https://www.youtube.com/watch?v=qQxcsE42958 막떠나려는 참이야 - i am about to leave, i am about to tell you 하는중이야 - i am on my way, i am on a break i’m here to help, i’m here to work , i’am here to see you i’m not here to fight, i’m not here to compete. i’m not here to say i ‘m sorry i’m ready to go, i’m ready to start [0404] What’s up? Nothing much You have a wrong number. Stop teasing me. 괴롭히지 마. Would you like some drink? Who cares! - 누가 신경써~ 아무도 Whar do you mean? Watch your language - 말 조심해~ unbelievable 말도 안 돼 things will (all) work out 다 잘 될 거야 there you are 음식을 내주면서 여기 있습니다. thanks for the compliment 칭찬 감사합니다 tell me about it 내말이(동의) take your time 천천히 해 he’s my type 걔 내 스타일이야 say that again? 뭐 ?, 다시 말해줘 can you pick me up? 나 좀 데리러 와줘 make yourself at home (너네 집처럼) 편하게 있어 let’s get together sometime 다음에 또 보자 keep going 앞으로 계속 가/하던 일 계속해 just looking(around) 그냥 둘러보고 있어요 it’s my fault 내 잘못이야, 내 탓이야 it’s time for lunch 점심시간이야 today is chilly, it’s chilly 오늘 쌀쌀하다 today is hot and humid 오늘 후덥지근하다 i love it 나 그거 정말 좋아 i made it 해냈어요 you made it 니가 해났어 i’ve had enough. i quit 안 해 때려치워,그만할래 i can handle it 나 할 수 있어 i can’t afford that 나 여유가 없어(경제적으로)","categories":[{"name":"영어","slug":"영어","permalink":"http://yoursite.com/categories/%EC%98%81%EC%96%B4/"}],"tags":[{"name":"제시카","slug":"제시카","permalink":"http://yoursite.com/tags/%EC%A0%9C%EC%8B%9C%EC%B9%B4/"},{"name":"300 문장","slug":"300-문장","permalink":"http://yoursite.com/tags/300-%EB%AC%B8%EC%9E%A5/"}]},{"title":"aws gamelift","slug":"dev-gamelift","date":"2020-01-11T05:30:19.000Z","updated":"2022-09-18T12:11:01.113Z","comments":true,"path":"2020/01/11/dev-gamelift/","link":"","permalink":"http://yoursite.com/2020/01/11/dev-gamelift/","excerpt":"install gamelift SDK for linux SDK 다운(https://ap-northeast-2.console.aws.amazon.com/gamelift/home?region=ap-northeast-2#/) cmake 설치.(yum install cmake) 해당 폴더(/home/gamelift/gamelift_sdk)에서 cmake CMakeLists.txt(makefile 생성) make","text":"install gamelift SDK for linux SDK 다운(https://ap-northeast-2.console.aws.amazon.com/gamelift/home?region=ap-northeast-2#/) cmake 설치.(yum install cmake) 해당 폴더(/home/gamelift/gamelift_sdk)에서 cmake CMakeLists.txt(makefile 생성) make cd thirdparty cmake CMakeLists.txt make(makefile 생성) cd /home/gamelift/gamelift_sdk/prefix/lib8.1 libprotobuf.so, libboost_date_time.so, libboost_system.so, libboost_random.so, libprotoc.so (해당 동적 라이브러리가 생성되었는지 확인) library PATH 넣어주기.9.1 vi /etc/profile9.2 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/gamelift/gamelift_sdk/prefix/lib 넣어준다.9.3 source /etc/profile(바로 적용)9.4 echo $LD_LIBRARY_PATH(위에 라이브러리가 추가 되었는지 확인) gamelift 사용하는 방법(예제) 문서(GameLift_dist.pdf) https://github.com/padhansell/GameLift/blob/master/GameLift_dist.pdf 다운로드(https://github.com/zeliard/GameLift) GameLiftLinuxServer 폴더에서 cmake CMakeLists.txt(makefile 생성) make 자신의 서버 소스에 gamelift를 추가 하는 방법 소스 컴파일(make, make install)1.1 vi makefile1.2 -L/home/gamelift/gamelift_sdk/prefix/lib -lsioclient -lboost_date_time -lboost_random -lboost_system -lprotobuf -lpthread (lib 추가) -I/home/gamelift/gamelift_sdk/prefix/include(include 추가) GameLiftManager.cpp Log.cpp 추가(gamelift 예제 소스에서 가지고 옴)1.3 make 아마존 게임리프트 콘솔에 올리는 방법 아마존 게임리프트 콘솔 도움말http://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/fleets-creating.html gamelift console 설정(https://ap-northeast-2.console.aws.amazon.com/gamelift/home?region=ap-northeast-2#/r/fleets/create) - 아마존 계정을 만들어야 한다.2.1 aws 액세스 키 생성https://docs.aws.amazon.com/ko_kr/general/latest/gr/managing-aws-access-keys.html2.2 게임서버에 session key, secret key 추가.2.2.1 해당 게임서버에서 AWS cli 설치 및 키 추가(http://pyrasis.com/book/TheArtOfAmazonWebServices/Chapter30/02)2.2.2 해당 서버에 실행 폴더를 AWS cli 통해서 gamelift에 올림.aws gamelift upload-build –name GameLiftLinuxServer5 –build-version 0.0.1 –build-root /home/gamelift/GameLift-master/GameLiftLinuxServer/build –operating-system AMAZON_LINUX –region ap-northeast-22.2.3 aws gamelift describe-build –build-id (올라 갔는지 확인)2.3 gamelift cosole 접속(직접 들어가서 해야 한다.)","categories":[{"name":"개발","slug":"개발","permalink":"http://yoursite.com/categories/%EA%B0%9C%EB%B0%9C/"}],"tags":[{"name":"aws","slug":"aws","permalink":"http://yoursite.com/tags/aws/"},{"name":"gamelift","slug":"gamelift","permalink":"http://yoursite.com/tags/gamelift/"}]}]}